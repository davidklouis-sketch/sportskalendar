name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: |
          frontend/package-lock.json
          backend/package-lock.json
    
    - name: Install frontend dependencies
      run: cd frontend && npm ci
    
    - name: Install backend dependencies
      run: cd backend && npm ci
    
    - name: Test frontend
      run: cd frontend && npm run build
    
    - name: Test backend
      run: cd backend && npm run build

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
    
    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:${{ github.sha }}
        build-args: |
          VITE_API_URL=https://api.sportskalendar.de/api
    
    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend:${{ github.sha }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Check deployment secrets
      run: |
        if [ -z "${{ secrets.HOST }}" ] || [ -z "${{ secrets.USERNAME }}" ] || [ -z "${{ secrets.SSH_KEY }}" ]; then
          echo "‚ùå Deployment secrets not configured"
          echo "Please configure the following secrets in GitHub:"
          echo "- HOST: Your server hostname"
          echo "- USERNAME: Your SSH username"
          echo "- SSH_KEY: Your private SSH key"
          exit 1
        fi
        echo "‚úÖ Deployment secrets configured"
    
    - name: Deploy to server
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.SSH_KEY }}
        port: ${{ secrets.SSH_PORT || '22' }}
        script: |
          set -e
          
          echo "üöÄ Starting deployment..."
          
          # Navigate to project directory
          cd /home/***/sportskalendar
          
          # Debug: Check if files exist
          echo "üîç Checking directory contents..."
          ls -la
          echo "üîç Checking for docker-compose files..."
          ls -la docker-compose*.yml
          echo "üîç Checking for .env.production..."
          ls -la .env.production
          
          # Pull latest images
          echo "üì• Pulling latest images..."
          docker compose -f docker-compose.traefik.yml --env-file .env.production pull
          
          # Create backup directory if it doesn't exist
          mkdir -p /home/dl/sportskalendar/backups
          
          # Create database backup BEFORE stopping services
          echo "üíæ Creating database backup..."
          if docker compose -f docker-compose.traefik.yml --env-file .env.production ps postgres | grep -q "Up"; then
            echo "PostgreSQL container is running, creating backup..."
            
            # Check current user count
            CURRENT_USERS=$(docker compose -f docker-compose.traefik.yml --env-file .env.production exec -T postgres psql -U sportskalendar -d sportskalendar -t -c "SELECT COUNT(*) FROM users;" 2>/dev/null | tr -d ' \n' || echo "0")
            echo "Current users before backup: $CURRENT_USERS"
            
            # List all users before backup
            echo "Users before backup:"
            docker compose -f docker-compose.traefik.yml --env-file .env.production exec -T postgres psql -U sportskalendar -d sportskalendar -c "SELECT email, display_name, role FROM users;" || echo "Could not list users"
            
            # Create data-only backup
            docker compose -f docker-compose.traefik.yml --env-file .env.production exec -T postgres pg_dump -U sportskalendar sportskalendar --data-only --column-inserts --no-owner --no-privileges > /tmp/db_backup.sql
            echo "Backup created: $(ls -la /tmp/db_backup.sql)"
            
            # Verify backup contains data
            if [ -s /tmp/db_backup.sql ]; then
              echo "‚úÖ Backup file is not empty"
              echo "Backup preview (first 10 lines):"
              head -10 /tmp/db_backup.sql
              echo "Checking for user data in backup:"
              grep -i "INSERT INTO users" /tmp/db_backup.sql || echo "‚ö†Ô∏è No user INSERT statements found in backup"
            else
              echo "‚ö†Ô∏è Backup file is empty!"
            fi
            
            # Create permanent backup
            TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
            PERMANENT_BACKUP="/home/dl/sportskalendar/backups/sportskalendar_backup_${TIMESTAMP}.sql"
            cp /tmp/db_backup.sql "$PERMANENT_BACKUP"
            gzip "$PERMANENT_BACKUP"
            echo "Permanent backup created: $PERMANENT_BACKUP.gz"
          else
            echo "PostgreSQL container not running, skipping backup"
          fi
          
          # Stop services gracefully
          echo "üõë Stopping services gracefully..."
          docker compose -f docker-compose.traefik.yml --env-file .env.production stop
          
          # Remove only the containers, NOT the volumes
          echo "üóëÔ∏è Removing containers (preserving volumes)..."
          docker compose -f docker-compose.traefik.yml --env-file .env.production rm -f
          
          # Deploy with zero-downtime (preserving volumes)
          echo "üöÄ Starting services with preserved volumes..."
          
          # Ensure the postgres_data volume exists
          echo "Ensuring postgres_data volume exists..."
          docker volume create postgres_data 2>/dev/null || echo "Volume already exists or could not be created"
          
          # Start services
          docker compose -f docker-compose.traefik.yml --env-file .env.production up -d
          
          # Wait for database to be ready
          echo "‚è≥ Waiting for database to be ready..."
          sleep 15
          
          # Wait for database to be actually accessible
          echo "üîç Checking database accessibility..."
          for i in {1..10}; do
            if docker compose -f docker-compose.traefik.yml --env-file .env.production exec -T postgres psql -U sportskalendar -d sportskalendar -c "SELECT 1;" >/dev/null 2>&1; then
              echo "Database is accessible after $i attempts"
              break
            else
              echo "Database not ready, attempt $i/10, waiting 3 seconds..."
              sleep 3
            fi
          done
          
          # Check if database is empty and restore if needed
          echo "üîç Checking database status..."
          USER_COUNT=$(docker compose -f docker-compose.traefik.yml --env-file .env.production exec -T postgres psql -U sportskalendar -d sportskalendar -t -c "SELECT COUNT(*) FROM users;" 2>/dev/null | tr -d ' \n' || echo "0")
          echo "Current user count: $USER_COUNT"
          
          if [ "$USER_COUNT" = "0" ]; then
            echo "üö® Database is empty, attempting restoration..."
            
            # Try to restore from backup
            if [ -f /tmp/db_backup.sql ] && [ -s /tmp/db_backup.sql ]; then
              echo "Restoring from backup..."
              echo "Backup file size: $(wc -c < /tmp/db_backup.sql) bytes"
              echo "Backup preview (first 5 lines):"
              head -5 /tmp/db_backup.sql
              
              # Clear existing data first, then restore
              echo "Clearing existing data..."
              docker compose -f docker-compose.traefik.yml --env-file .env.production exec -T postgres psql -U sportskalendar -d sportskalendar -c "TRUNCATE TABLE users, sessions, security_events, highlights RESTART IDENTITY CASCADE;"
              
              # Restore only data (skip schema conflicts)
              echo "Restoring data from backup..."
              docker compose -f docker-compose.traefik.yml --env-file .env.production exec -T postgres psql -U sportskalendar -d sportskalendar --single-transaction < /tmp/db_backup.sql
              
              # Verify restoration
              echo "Verifying restoration..."
              docker compose -f docker-compose.traefik.yml --env-file .env.production exec -T postgres psql -U sportskalendar -d sportskalendar -c "SELECT email, display_name, role FROM users;" || echo "Could not list users after restore"
            else
              echo "‚ö†Ô∏è No backup found, database will be empty"
            fi
            
            echo "Restoration completed, checking user count..."
            FINAL_USER_COUNT=$(docker compose -f docker-compose.traefik.yml --env-file .env.production exec -T postgres psql -U sportskalendar -d sportskalendar -t -c "SELECT COUNT(*) FROM users;" 2>/dev/null | tr -d ' \n' || echo "0")
            echo "Final user count after restoration: $FINAL_USER_COUNT"
            if [ "$FINAL_USER_COUNT" -gt "0" ]; then
              echo "‚úÖ Database restoration successful - $FINAL_USER_COUNT users found"
            else
              echo "‚ö†Ô∏è Database restoration failed - no users found"
            fi
          else
            echo "Database has $USER_COUNT users, skipping restoration"
          fi
          
          # Clean up old images
          echo "üßπ Cleaning up old images..."
          docker image prune -f
          
          echo "‚úÖ Deployment completed successfully!"
